<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <script src="./jquery-3.2.1.slim.min.js"></script>
    <title>virtual-DOM v01 : Tree</title>
  </head>
  <body></body>
</html>
<script>
  // https://code.tutsplus.com/articles/data-structures-with-javascript-tree--cms-23393

  /*
    OPERATIONS:
    Node{id: "id", parent: null, children:[], data:[]}

    TREE:
    - _root
    - dfs(callback)
    - bfs(callback)
    - find(id, traversal)
    - add(node, parentId, traverse)
    - remove(childId, parentId)

  */

  /**
   * nodeId: string id of current node
   * parent: reference of parent node. null for root node
   * children: arrays of child nodes reference
   * data: arrays of properties map
   *
   * Eg:
   * <div id="container" class="container bg-white w-100"></div>
   *
   * new Node("container", null, [], {"class_": "container bg-white w-100" })
   */
  function Node(nodeId, parent, children, data) {
    this.id = !nodeId ? generateId() : nodeId;
    this.parent = !parent ? null : parent;
    this.children = !children ? [] : children;
    this.data = !data ? {} : data;
  }

  Node.prototype.findChildByIndex = function (index) {
    if (!this.children[index]) {
      // un-trusted, undefined
      return null;
    }
    return this.children[index];
  };

  Node.prototype.firstChild = function () {
    if (!this.children[0]) {
      // un-trusted, undefined
      return null;
    }
    return this.children[0];
  };

  Node.prototype.lastChild = function () {
    if (!this.children[this.children.length-1]) {
      // un-trusted, undefined
      return null;
    }
    return this.children[this.children.length-1];
  };

  Node.prototype.findChildIndexById = function (nodeId) {
    for (var i = 0, length = this.children.length; i < length; i++) {
      if (this.children[i].id == nodeId) {
        return i;
      }
    }
    return null;
  };

  function generateId() {
    return new Date().getTime() + "-" + uuidv4();
  }

  function uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (
      c
    ) {
      var r = (Math.random() * 16) | 0,
        v = c == "x" ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }

  function Tree(nodeId) {
    var node = new Node(nodeId);
    this.root = node;
  }

  Tree.prototype.dfs = function (callback) {
    // we will write a recursive function and invoke it with root node
    (function traverse(node) {
      callback(node);
      for (var i = 0, length = node.children.length; i < length; i++) {
        traverse(node.children[i]);
      }
      // callback(node);
    })(this.root);
  };

  Tree.prototype.bfs = function (callback) {
    var queue = new Queue();
    queue.enqueue(this.root);
    var node = queue.dequeue();
    while (node) {
      callback(node);

      // add all child to queue
      for (var i = 0, length = node.children.length; i < length; i++) {
        queue.enqueue(node.children[i]);
      }

      // callback(node);
      node = queue.dequeue();
    }
  };

  // searches for a node in a tree.
  Tree.prototype.contains = function (callback, traverse) {
    traverse.call(this, callback);
  };

  Tree.prototype.add = function (nodeId, parentId, traverse) {
    var childNode = new Node(nodeId);
    var parentNode = null;
    var callback = function (node) {
      if (node.id == parentId) {
        parentNode = node;
      }
    };
    this.contains(callback, traverse);
    if (parentNode) {
      parentNode.children.push(childNode);
      childNode.parent = parentNode;
    } else {
      throw new Error("could not add node to undefined parent");
    }
  };

  Tree.prototype.remove = function (nodeId, parentId, traverse) {
    var tree = this;
    var parent = null;
    var childToRemove = null;
    var childIndexInParent = -1;

    var callback = function (node) {
      if (node.id == parentId) {
        parent = node;
      }
    };

    this.contains(callback, traverse);

    if (parent) {
      childIndexInParent = parent.findChildIndexById(nodeId);
      if (!childIndexInParent) {
        throw new Error("node to remove does not exists.");
      }
      childToRemove = parent.children.splice(childIndexInParent, 1);
    } else {
      throw new Error("parent does not exist.");
    }

    return childToRemove;
  };

  Tree.prototype.findNodeById = function (nodeId) {// TODO: map can be used for fast access, (parentId + nodeId)
    var queue = new Queue();
    queue.enqueue(this.root);
    var node = queue.dequeue();
    while (node) {
      if (node.id == nodeId) {
        return node;
      }

      // add all child to queue
      for (var i = 0, length = node.children.length; i < length; i++) {
        queue.enqueue(node.children[i]);
      }

      // callback(node);
      node = queue.dequeue();
    }

    return null;
  };

  Tree.prototype.findPreviousSibling = function (nodeId) {
    var node = this.findNodeById(nodeId);
    if (!node) {
      console.log("Element not found with id", nodeId);
      return null;
    }
    var parent = node.parent;
    var nodeIndex = parent.findChildIndexById(nodeId);
    // previous sibling
    return parent.findChildByIndex(nodeIndex - 1);
  };

  Tree.prototype.findNextSibling = function (nodeId) {
    var node = this.findNodeById(nodeId);
    if (!node) {
      console.log("Element not found with id", nodeId);
      return null;
    }
    var parent = node.parent;
    var nodeIndex = parent.findChildIndexById(nodeId);
    // next sibling
    return parent.findChildByIndex(nodeIndex + 1);
  };

  function Queue() {
    this.list = [];

    this.enqueue = function enqueue(data) {
      this.list.push(data);
    };

    this.dequeue = function dequeue() {
      return this.list.shift();
    };

    this.front = function front() {
      return this.list[0];
    };

    this.back = function back() {
      return this.list[this.list.length - 1];
    };
  }

  // Test Tree
  var things = new Tree("things");
  things.add("cloths", "things", things.bfs);
  things.add("food", "things", things.bfs);
  things.add("books", "things", things.bfs);

  things.add("shirt", "cloths", things.bfs);
  things.add("paint", "cloths", things.bfs);
  things.add("tshirt", "cloths", things.bfs);
  things.add("tie", "cloths", things.bfs);

  things.add("fruits", "food", things.bfs);
  things.add("vegetables", "food", things.bfs);

  things.add("english", "books", things.bfs);
  things.add("hindi", "books", things.bfs);
  things.add("maths", "books", things.bfs);
  things.add("science", "books", things.bfs);
  things.add(null, "science", things.bfs);
  things.add(null, "science", things.bfs);
  things.add(null, "science", things.bfs);
  things.add(null, "science", things.bfs);
  things.add(null, "science", things.bfs);

  things.bfs(function (node) {
    console.log(node.id);
  });

  $(document).ready(function () {
    //end
  });
</script>
